# Modeling with Gaussian processes

The goal in this tutorial is to visualize the deformations generated by a Gaussian process model and compute a smooth deformation model of the reference mesh.


We start as always by importing the data structures we will need and by initializing Scalismo:


```scala
import java.io.File
import scalismo.common.{BoxDomain, NearestNeighborInterpolator}
import scalismo.geometry.{EuclideanVector, IntVector, _3D}
import scalismo.image.DiscreteImageDomain
import scalismo.io.{ImageIO, MeshIO, StatisticalModelIO}
import scalismo.kernels.{DiagonalKernel, GaussianKernel}
import scalismo.statisticalmodel.{GaussianProcess, LowRankGaussianProcess, StatisticalMeshModel}
import scalismo.ui.api.{ScalismoUI, TransformationGlyph}
import scalismo.common.interpolation.LinearImageInterpolator3D


scalismo.initialize()
implicit val rng = scalismo.utils.Random(42)

```

We also launch a UI instance

```scala
val ui = ScalismoUI()
    
```

We start by defining our Gaussian process:

```scala
val kMat = DiagonalKernel(
    GaussianKernel[_3D](sigma = 80) * 50,
    GaussianKernel[_3D](sigma = 80) * 50,
    GaussianKernel[_3D](sigma = 80) * 250
)

val gp = GaussianProcess[_3D, EuclideanVector[_3D]](kMat)

```

Here the sigma parameter influences the radius of correlation on the reference
domain, while the scaling factor (50, 250) influences the norm of the sampled deformation
vectors at each point. Notice how we indicate a 5 times stronger deformation on the Z-axis
that coincides with the longitudinal axis of the bone.

In order to sample deformations out of our model, we need a discrete domain.

We load a CT image and define a discrete grid (of size (10, 10, 20)) on its bounding box:

```scala
val refImage = ImageIO.read3DScalarImage[Short](
    new File("./datasets/1.nii")
).get


val refGroup = ui.createGroup("reference")
val refImageView = ui.show(refGroup, refImage, "ref-image")
   

val gpDomain = refImage.domain.boundingBox
val deformationGrid = DiscreteImageDomain(gpDomain, size = IntVector(10, 10, 20))

```

We can now compute a low-rank approximation of our GP on this grid, where we retain 90% of
the original model's variance (i.e indicated 0.1 tolerance):

```scala
val lowRankGP = LowRankGaussianProcess.approximateGPCholesky(
    deformationGrid,
    gp,
    0.1,
    LinearImageInterpolator3D[EuclideanVector[_3D]]()
)

```

To visualize the sampled deformations out of the discrete low-rank GP, we add
its transformation to the scene

```scala
val transformationView = ui.addTransformation(
    refGroup,
    lowRankGP,
    "gp"
)

ui.show(refGroup,
   TransformationGlyph(deformationGrid.points.toIndexedSeq),
   "glyphs"
)

```

**Exercise**: Click on the reference Group, then press the random button to visualize
the sampled deformation fields.


When adding the reference mesh to the group, we can see that it get deformed with the sampled
deformation fields, therefore generating new random shapes


```scala
val refMesh = MeshIO.readMesh(new File("./datasets/1.stl")).get

ui.show(refGroup, refMesh, "reference mesh")

```

**Exercise**: try changing the parameters of the kernel above (and recompute the GP) to get
a feeling of the parameters effect.


To get a bit more detailed shape deformations, we add a smaller kernel to the previous one in
in order to sample less global deformations (e.g. bumps)

```scala
val kMat2 = DiagonalKernel(
    GaussianKernel[_3D](sigma = 80) * 50 + GaussianKernel[_3D](sigma = 40) * 20,
    GaussianKernel[_3D](sigma = 80) * 50 + GaussianKernel[_3D](sigma = 40) * 20,
    GaussianKernel[_3D](sigma = 80) * 250 + GaussianKernel[_3D](sigma = 40) * 80
)

val gp2 = GaussianProcess[_3D, EuclideanVector[_3D]](kMat2)

```

Since we are only interested in a surface deformation model, we compute the
low-rank approximation only on the points of the reference mesh
(this time retaining 99% of the variance)

```scala
// we approximate only on the mesh and save it as a shape model
val lowRankGPRefMesh = LowRankGaussianProcess.approximateGPCholesky(
    refMesh.pointSet,
    gp2,
    0.01,
    NearestNeighborInterpolator()
)

```

Using this low-rank GP, we can now compute a statistical shape model, modeling smooth deformations of our reference shape

```scala
val meshModel = StatisticalMeshModel(refMesh, lowRankGPRefMesh)

val meshModelGroup = ui.createGroup("ssm")
ui.show(meshModelGroup, meshModel, "ssm")

```

**Exercise**: Visualize the random shapes resulting from this model using the Random button in the UI


Finally, we can save our model to file in order to use it in the next tutorials:

```scala
val targetFile = new File("./datasets/femur-mesh-model.h5")
StatisticalModelIO.writeStatisticalMeshModel(meshModel, targetFile).get

```

