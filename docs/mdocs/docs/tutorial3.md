{% include head.html %}

# Model fitting with Metropolis Hastings

The goal in this tutorial is to fit our previously computed Gaussian process deformation model to a target shape.


We start as always by importing the data structures we will need and by initializing Scalismo:



```scala mdoc:silent
import java.awt.Color
import breeze.linalg.{DenseMatrix, DenseVector}
import fitting.evaluators.{ClosestPointEvaluator, PriorEvaluator}
import fitting.logger.Logger
import fitting.parameters.{Parameters, Sample}
import fitting.proposals.{RotationUpdateProposal, ShapeICPProposal, ShapeUpdateProposal, TranslationUpdateProposal}
import scalismo.io.{MeshIO, StatisticalModelIO}
import scalismo.sampling.algorithms.MetropolisHastings
import scalismo.sampling.evaluators.ProductEvaluator
import scalismo.sampling.proposals.MixtureProposal
import scalismo.statisticalmodel.MultivariateNormalDistribution
import scalismo.ui.api.ScalismoUI
import utils.CachedEvaluator
import scalismo.geometry.EuclideanVector
import utils.Utils._
import java.io.File
scalismo.initialize()
implicit val rng = scalismo.utils.Random(42)
```

We also launch a GUI
```scala mdoc:silent
val ui = ScalismoUI()
```
   
In this case, we wish to fit our GP model (previously built) to a target mesh. 
We therefore load both the target and model and display them in the UI:

```scala mdoc:silent   
val targetMesh = MeshIO.readMesh(new File("datasets/9.stl")).get

val shapeModel = StatisticalModelIO.readStatisticalMeshModel(
    new File("datasets/femur-mesh-model.h5")
).get


val modelGroup = ui.createGroup("model")
val modelView = ui.show(modelGroup, shapeModel, "model")
modelView.meshView.opacity = 1.0
modelView.meshView.color = Color.RED

val targetGroup = ui.createGroup("target")
val targetView = ui.show(targetGroup, targetMesh, "target mesh")
```

In addition to the difference in shape between the model mean and the target, 
notice how the model and target are rigidly misaligned.

#### Proposal generators

We need proposal generators that update the parameters for the translation and rotation of the model

```scala mdoc:silent       
val rotationUpdateProposal = RotationUpdateProposal(0.001)
val translationUpdateProposal = TranslationUpdateProposal(0.1)
```
   
In order to fit the shape parameters to the target, we also include a random shape update proposal

```scala mdoc:silent        
val shapeUpdateProposal = ShapeUpdateProposal(shapeModel.rank, 0.01)
```

To speed up the convergence, we include an "informed" shape proposal, that does not simply update the
shape parameters in a random way, but performs a non-rigid ICP shape update. ICP is out of the scope of this
workshop, so we will not focus on it here. For more details on ICP, you can refer to the FutureLearn course.

```scala mdoc:silent   
val pointwiseNoiseVariance = 1.0
val uncertainty = MultivariateNormalDistribution(
    DenseVector.zeros[Double](3),
    DenseMatrix.eye[Double](3) * pointwiseNoiseVariance
)
val shapeICPProposal = ShapeICPProposal(shapeModel, targetMesh, uncertainty, 1.0)
```

To obtain the final pose and shape proposal, we simply mix the previous proposals
into one, indicating, for each, a propability of being selected (i.e. below we would be 
drawing samples from the rotation proposal around 20% of the time)

```scala mdoc:silent  
val poseAndShapeMixture = MixtureProposal.fromProposalsWithTransition(
    (0.2, rotationUpdateProposal),
    (0.2, translationUpdateProposal),
    (0.05, shapeICPProposal),
    (0.55, shapeUpdateProposal)
)
```

#### Proposal evaluators
We now define the proposal evaluators, evaluating the likelihood of the samples generated by the proposals above.

We start by defining a shape prior evaluator that for every proposed shape coefficients returns
their likelihood according to the indicated shape model. We cache the evaluation for performance reasons.

```scala mdoc:silent  
val priorEvaluator = CachedEvaluator(PriorEvaluator(shapeModel))
```

To evaluate the distance to the target shape, we use the ClosestPointEvaluator below.
Given current pose and shape parameters, this evaluator will simply generate the corresponding shape, transpose
it accordingly, then evaluate the likelihood of its distance to the target for a selected set points sampled on the target.

```scala mdoc:silent 
val closestPointEvaluator = CachedEvaluator(ClosestPointEvaluator(shapeModel, targetMesh, uncertainty))
```

We then combine these two evaluators into a single one taking the product of the two likelihoods.

```scala mdoc:silent   
val posteriorEvaluator = ProductEvaluator(
    priorEvaluator,
    closestPointEvaluator
)
```

#### Building and sampling from the chain

We can now build our Metropoolis Hastings chain using these combined proposal generators and evaluators

```scala mdoc:silent
val chain = MetropolisHastings(poseAndShapeMixture, posteriorEvaluator)
```

In order to start sampling from the chain, we indicate  null initial parameters for both pose and shape.

```scala mdoc:silent
val initialParameters = Parameters(
    EuclideanVector(0, 0, 0),
    (0.0, 0.0, 0.0),
    DenseVector.zeros[Double](shapeModel.rank)
)
val initialSample = Sample("initial", initialParameters, computeCenterOfMass(shapeModel.mean))
```

To be able to track the progress of the sampling chain, we indicate a logger tracking the acceptance and 
rejection of our samples and wrap the
the iterations with a visualization task where every 50th accepted sample will be displayed in the UI


```scala mdoc:silent
val chainLogger = new Logger()
val chainIterator = visualizeSamples(
    chain.iterator(initialSample, chainLogger),  modelView
)
```

We can now finally draw the samples out of our chain. Here we drop the first 500 samples to ignore the samples
generated during the burn-in phase. After that we take 1000 samples.
    
```scala mdoc:silent    
val samples = chainIterator.drop(500).take(1000).toIndexedSeq
```

Once all the samples drawn, we now select the best sample (out of the 1000 above) according to our
combined evaluator


```scala mdoc:silent  
val bestSample = samples.maxBy(s => posteriorEvaluator.logValue(s))
val bestMesh = shapeModel.instance(bestSample.parameters.modelCoefficients).transform(bestSample.poseTransformation)
```

We then display the best fit in the UI
```scala mdoc:silent  
val resultGroup = ui.createGroup("result")
ui.show(resultGroup, bestMesh, "best fit")
```

To be able to debug the results of our chain, we can inspect the acceptance ratios of each proposal
generator using the state logged by the chain logger

```scala mdoc:silent  
println(chainLogger.acceptanceRatios())
```




